<?xml version="1.0" encoding="UTF-8"?>
<FBType Name="GEN_SQR" Comment="this signal generator generates a square wave output">
	<Identification Standard="61499-1" Description="version 1.4&#9;11. mar. 2009&#10;programmer &#9;oscat&#10;tested BY&#9;&#9;oscat&#10;&#10;this signal generator generates a square wave output. The square wave signal is defined by period time (PT), &#10;amplitude (AM), offset (OS), duty cycle (DC) and a specific delay for the output signal (DL).&#10;The Output waveform will switch between AM/2 + OS and -AM/2 + OS. The DC input specifies ther duty cycle, &#10;DC = 0 means output is low at all times and 1 means output is high at all times.&#10;The delay input can delay a signal up to PT, this can be useful to synchronize different generators and generate interleaving signals.&#10;in addition to a analog output Out there is a second boolean output Q.">
	</Identification>
	<VersionInfo Version="1.0" Author="franz" Date="2025-12-21">
	</VersionInfo>
	<CompilerInfo packageName="OSCAT::Basic::POUs::Engineering::signal_generators">
		<Import declaration="OSCAT::Basic::POUs::Mathematical::MODR"/>
		<Import declaration="OSCAT::Basic::POUs::Time_Date::MULTIME"/>
	</CompilerInfo>
	<InterfaceList>
		<EventInputs>
			<Event Name="INIT" Type="EInit" Comment="Init Request">
				<With Var="PT"/>
				<With Var="AM"/>
				<With Var="OS"/>
				<With Var="DC"/>
				<With Var="DL"/>
			</Event>
			<Event Name="REQ" Type="Event" Comment="Normal Execution Request">
				<With Var="PT"/>
				<With Var="AM"/>
				<With Var="OS"/>
				<With Var="DC"/>
				<With Var="DL"/>
			</Event>
			<Event Name="RST" Type="Event" Comment="Reset">
			</Event>
		</EventInputs>
		<EventOutputs>
			<Event Name="INITO" Type="EInit" Comment="Init Confirmation">
				<With Var="Q"/>
				<With Var="Out"/>
			</Event>
			<Event Name="CNF" Type="Event" Comment="Execution Confirmation">
				<With Var="Q"/>
				<With Var="Out"/>
			</Event>
		</EventOutputs>
		<InputVars>
			<VarDeclaration Name="PT" Type="TIME" Comment="Period Time"/>
			<VarDeclaration Name="AM" Type="REAL" Comment="Amplitude" InitialValue="1.0"/>
			<VarDeclaration Name="OS" Type="REAL" Comment="Offset"/>
			<VarDeclaration Name="DC" Type="REAL" Comment="Duty Cycle" InitialValue="0.5"/>
			<VarDeclaration Name="DL" Type="REAL" Comment="Delay"/>
		</InputVars>
		<OutputVars>
			<VarDeclaration Name="Q" Type="BOOL" Comment="Pulse Output"/>
			<VarDeclaration Name="Out" Type="REAL" Comment="Signal Output"/>
		</OutputVars>
	</InterfaceList>
	<SimpleFB>
		<InternalVars>
			<VarDeclaration Name="tx" Type="TIME"/>
			<VarDeclaration Name="last" Type="TIME"/>
			<VarDeclaration Name="init" Type="BOOL"/>
			<VarDeclaration Name="DL_M" Type="REAL"/>
			<VarDeclaration Name="DC_M" Type="REAL"/>
		</InternalVars>
		<ECState Name="INIT">
			<ECAction Algorithm="INIT" Output="INITO"/>
		</ECState>
		<ECState Name="REQ">
			<ECAction Algorithm="REQ" Output="CNF"/>
		</ECState>
		<ECState Name="RST">
			<ECAction Algorithm="RST" Output="CNF"/>
		</ECState>
		<Algorithm Name="INIT">
			<ST><![CDATA[ALGORITHM INIT
init := FALSE;
END_ALGORITHM]]></ST>
		</Algorithm>
		<Algorithm Name="RST">
			<ST><![CDATA[

ALGORITHM RST
init := TRUE;
last := tx;
tx := T#0s;
END_ALGORITHM]]></ST>
		</Algorithm>
		<Algorithm Name="REQ">
			<ST><![CDATA[

ALGORITHM REQ
(* check dc = 1 or 0 *)
IF DC = 0.0 THEN
	Out := -AM * 0.5 + OS;
	Q := FALSE;
	RETURN;
ELSIF DC = 1.0 THEN
	Out := AM * 0.5 + OS;
	Q := TRUE;
	RETURN;
END_IF;

(* read system time and prepare input data *)
tx := NOW_MONOTONIC() - last;
DL_M := MODR(DL, 1.0);
IF DL_M < 0.0 THEN
	DL_M := 1.0 - DL_M;
END_IF;
DC_M := MODR(DC, 1.0);
IF DC_M < 0.0 THEN
	DC_M := 1.0 - DC_M;
END_IF;

(* init section *)
IF NOT init THEN
	this.RST();
END_IF;

(* add last if one cycle is finished *)
IF tx >= PT THEN
	last := last + PT;
	tx := tx - PT;
END_IF;

(* check if falling or rising edge first *)
IF MULTIME(PT, DL + DC) >= PT THEN
	(* generate falling edge *)
	IF tx >= MULTIME(PT, DL + DC - 1.0) THEN
		Out := -AM * 0.5 + OS;
		Q := FALSE;
	END_IF;
	(* generate rising edge *)
	IF tx >= MULTIME(PT, DL) THEN
		Out := AM * 0.5 + OS;
		Q := TRUE;
	END_IF;
ELSE
	(* generate rising edge first *)
	IF tx >= MULTIME(PT, DL) THEN
		Out := AM * 0.5 + OS;
		Q := TRUE;
	END_IF;
		(* generate falling edge *)
	IF tx >= MULTIME(PT, DL + DC) THEN
		Out := -AM * 0.5 + OS;
		Q := FALSE;
	END_IF;
END_IF;
END_ALGORITHM

(* revision history
 * *
 * hm	12. feb 2007	rev 1.1 added default value for dc = 0.5
 * *
 * hm	17 sep 2007	rev 1.2 replaced time() with t_plc_ms for compatibilitx reasons
 * *
 * hm	6. jan 2008	rev 1.3 improved performance
 * *
 * hm	11. mar. 2009	rev 1.4 changed real constants to use dot syntax set default amplitude to 1.0 *) ]]></ST>
		</Algorithm>
	</SimpleFB>
</FBType>
